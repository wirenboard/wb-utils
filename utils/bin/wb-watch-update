#!/bin/bash
# vim: set noexpandtab:
#set -x
UPDATE_FIT_END_SIGNATURE="__WB_UPDATE_FIT_END__"
UPDATE_LOG="/var/log/update.log"

PID_FILE="/var/run/wb-watch-update.pid"

AB_WATCH_DIR="/var/www/uploads"
SINGLE_WATCH_DIR="/mnt/data/.wb-update"

WATCH_DIR_SYMLINK="/var/run/wb-watch-update.dir"

cleanup() {
	[[ -f "$PID_FILE" ]] && kill `cat "$PID_FILE"` 2>/dev/null
	rm -f "$PID_FILE"
}

check_fully_received() {
	local sig_len=`echo -n "$UPDATE_FIT_END_SIGNATURE" | wc -c`
	local sig=`tail -c $sig_len $1`
	[[ "$sig" == "$UPDATE_FIT_END_SIGNATURE" ]]
}

cleanup_watch_dir() {
	find $WATCH_DIR/ -maxdepth 1 -type f "$@" -delete
}

log() {
	logger -t wb-watch-update "$*"
}

mqtt_status() {
	mosquitto_pub -r -t /firmware/status -m "$*"
}

mqtt_log_retain() {
	mosquitto_pub -t /firmware/log -m "$*" -r
}

mqtt_log() {
	mosquitto_pub -t /firmware/log -m "$*"
}

mqtt_log_pipe() {
	mosquitto_pub -t /firmware/log -l
}

mqtt_log_reset() {
	mosquitto_pub -t /firmware/log -m "" -r
}

DEFAULT_STATUS="IDLE"

maybe_publish_singlemode_update_status() {
	local logfile="$SINGLE_WATCH_DIR/state/update.log"
	local statusfile="$SINGLE_WATCH_DIR/state/update.status"

	if [ -e "$statusfile" ]; then
		if [ -e "$logfile" ]; then
			log "Seems like update just have been done, printing logs and saving it in retained"
			log "Saved status: $(cat "$statusfile")"
			log "Please reload page if there is no 'Done' button"

			mqtt_log_retain "$({
				echo ">>> Installation logs:"
				sed -e 's/^INFO /%%% /' -e 's/^REBOOT.*$/%%% (reboot)/' < "$logfile"
			})"
		fi

		# This is a combined status example. It should not be used anywhere
		# but in this tool in order to preseve compatibility.
		#
		# See app/scripts/react-directives/firmware-update/store.js in homeui
		# to know more about it.

		DEFAULT_STATUS="$({
			cat "$statusfile"
			echo -ne "\nIDLE"
		})"
		rm -rf "$statusfile"
	fi
}

if [ "$(blockdev --getsz /dev/mmcblk0p2)" -ne "$(blockdev --getsz /dev/mmcblk0p3)" ]; then
	log "using single rootfs update mode"
	WATCH_DIR="$SINGLE_WATCH_DIR"
else
	log "using legacy A/B update mode"
	WATCH_DIR="$AB_WATCH_DIR"
fi

maybe_publish_singlemode_update_status
mkdir -p "$WATCH_DIR"
chown www-data:www-data "$WATCH_DIR"
ln -snf "$WATCH_DIR" "$WATCH_DIR_SYMLINK"

LAST_FIT=''

(
	echo "$BASHPID" > "$PID_FILE"
	2>/dev/null exec inotifywait -m -r \
		--exclude $WATCH_DIR/state/ \
		--event close_write $WATCH_DIR/ \
) | {
trap cleanup EXIT

# wait for mosquitto to open socket
while ! mqtt_status "$DEFAULT_STATUS"; do
    sleep 1
done

while read EVENT_DIR EVENT_TYPE EVENT_FILE; do
	FIT="${EVENT_DIR}${EVENT_FILE}"

	# skip install_update.flags file event, it may be used for debugging
	case "$FIT" in
	*install_update.*)
		continue
		;;
	esac

	# Prevent endless loop
	[[ "$FIT" != "$LAST_FIT" ]] || continue
	[[ -e "$FIT" ]] || continue
	LAST_FIT=$FIT

	mqtt_log_reset

	# Ensure that image was received completely
	check_fully_received $FIT || {
		msg="Received incomplete update FIT $FIT, don't starting update"
		log "$msg"
		mqtt_status "ERROR $msg"
		mqtt_status "IDLE"
		rm -f $FIT
		LAST_FIT=""
		continue
	}

	# Remove old updates, we won't run it anyway
	cleanup_watch_dir -not -name ${EVENT_FILE} -not -name 'install_update.*'

	msg="Received good update FIT $FIT, starting update"
	log "$msg"
	mqtt_log "$msg"

	wb-run-update $FIT 2>&1 | tee -a "$UPDATE_LOG" | mqtt_log_pipe
	if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
		FIT=""
		LAST_FIT=""
	fi

	if [ -e "$SINGLE_WATCH_DIR/state/update.status" ] ; then
		log "Exiting wb-watch-update, restart is required by FIT"
		exit 0
	fi
	
	rm -f $FIT
done
}
